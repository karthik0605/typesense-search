<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Typesense Conversational (Direct Fetch)</title>
  <style>
    body { font-family: -apple-system, system-ui, sans-serif; margin: 2rem; }
    .row { display: flex; gap: 0.5rem; flex-wrap: wrap; }
    input, button { font-size: 16px; padding: 0.5rem; }
    #out { white-space: pre-wrap; margin-top: 0.5rem; }
    .muted { color: #666; font-size: 0.9em; }
  </style>
</head>
<body>
  <h1>Conversational Search (Direct Fetch)</h1>
  <div class="row">
    <input id="host" placeholder="host" size="20" />
    <input id="port" placeholder="8108" size="6" />
    <input id="protocol" placeholder="http" size="6" />
    <input id="apiKey" placeholder="Search-only API Key" size="30" />
  </div>
  <div class="row" style="margin-top: 0.5rem">
    <input id="q" placeholder="Ask a question" size="40" />
    <button id="go">Ask</button>
    <button id="reset">Reset conversation</button>
  </div>
  <div id="cid" class="muted" style="margin-top: 0.5rem"></div>
  <div id="out" class="muted"></div>

  <script>
    const hostEl = document.getElementById('host');
    const portEl = document.getElementById('port');
    const protocolEl = document.getElementById('protocol');
    const apiKeyEl = document.getElementById('apiKey');
    const qEl = document.getElementById('q');
    const goBtn = document.getElementById('go');
    const resetBtn = document.getElementById('reset');
    const outEl = document.getElementById('out');
    const cidEl = document.getElementById('cid');

    // Resolve config from URL params -> /config.json -> localStorage -> defaults
    const params = new URLSearchParams(location.search);
    const saved = JSON.parse(localStorage.getItem('ts_cfg') || '{}');

    function applyValues(cfg){
      if (!cfg) return;
      if (cfg.host) hostEl.value = cfg.host;
      if (cfg.port) portEl.value = String(cfg.port);
      if (cfg.protocol) protocolEl.value = cfg.protocol;
      if (cfg.searchKey) apiKeyEl.value = cfg.searchKey;
    }

    applyValues({
      host: params.get('host') || saved.host || '54.219.100.201',
      port: params.get('port') || saved.port || '8108',
      protocol: params.get('protocol') || saved.protocol || 'http',
      searchKey: params.get('apiKey') || saved.searchKey || ''
    });
    qEl.value = params.get('q') || 'suggest a chair under 1000';

    fetch('/config.json').then(r => r.ok ? r.json() : null).then(cfg => {
      if (cfg) applyValues(cfg);
    }).catch(() => {});

    let conversationId = undefined;

    async function ask() {
      const host = hostEl.value.trim();
      const port = portEl.value.trim();
      const protocol = protocolEl.value.trim() || 'http';
      const apiKey = apiKeyEl.value.trim();
      localStorage.setItem('ts_cfg', JSON.stringify({ host, port, protocol, searchKey: apiKey }));
      const q = qEl.value.trim();
      if (!host || !port || !q || !apiKey) return;

      outEl.innerHTML = '';

      const baseUrl = `${protocol}://${host}:${port}`;
      const qParam = encodeURIComponent(q).replace(/%20/g, '+');
      const cidParam = conversationId ? `&conversation_id=${encodeURIComponent(conversationId)}` : '';
      const url = `${baseUrl}/multi_search?q=${qParam}&conversation=true&conversation_stream=false&conversation_model_id=conv-model-1&prefix=false${cidParam}`;
      const body = JSON.stringify({
        searches: [
          { collection: 'seating', query_by: 'embedding', exclude_fields: 'embedding' }
        ]
      });

      try {
        const controller = new AbortController();
        const to = setTimeout(() => controller.abort(), 12000);
        let res;
        try {
          res = await fetch(url, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'X-TYPESENSE-API-KEY': apiKey
            },
            body,
            signal: controller.signal
          });
        } catch (e) {
          // Network/CORS/timeout -> proxy fallback
          // Always target local Typesense on the VM to avoid hairpinning to public IP
          const proxyUrl = `/proxy/multi_search?q=${qParam}&conversation=true&conversation_stream=false&conversation_model_id=conv-model-1&prefix=false${cidParam}&host=127.0.0.1&port=8108&protocol=http`;
          res = await fetch(proxyUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-TYPESENSE-API-KEY': apiKey },
            body
          });
        } finally {
          clearTimeout(to);
        }
        if (!res.ok) {
          const text = await res.text().catch(() => '');
          outEl.textContent = `[error] HTTP ${res.status}: ${text}`;
          return;
        }
        const data = await res.json();
        const conv = data?.conversation;
        if (conv?.conversation_id) {
          conversationId = conv.conversation_id;
          cidEl.textContent = 'conversation_id: ' + conversationId;
        }

        function escapeHtml(s) {
          return s
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
        }

        function renderMarkdownLite(md) {
          const escaped = escapeHtml(md || '');
          // Images: ![alt](url.ext)
          const withImgs = escaped.replace(/!\[([^\]]*)\]\((https?:[^)\s]+\.(?:jpg|jpeg|png|gif|webp)[^)]*)\)/gi, (_m, alt, url) => {
            const safeAlt = String(alt || '').replace(/\"/g, '&quot;');
            return '<img src="' + url + '" alt="' + safeAlt + '" style="width:72px;height:72px;object-fit:cover;border-radius:6px;vertical-align:middle;margin:0.25rem 0" loading="lazy" />';
          });
          // Links: [text](url)
          const withLinks = withImgs.replace(/\[([^\]]+)\]\((https?:[^)\s]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1<\/a>');
          // Bold: **text**
          const withBold = withLinks.replace(/\*\*([^*]+)\*\*/g, '<strong>$1<\/strong>');
          // Strip common bullet prefixes at line start: hyphen, en dash, em dash, bullet
          const withoutDash = withBold.replace(/^\s*[-–—•]\s+/gm, '');
          // Newlines → <br>
          return withoutDash.replace(/\n/g, '<br>');
        }

        async function renderSuggestions() {
          try {
            const sugUrl = `${baseUrl}/multi_search?q=${qParam}&conversation=false&conversation_stream=false&prefix=true`;
            const sugBody = JSON.stringify({ searches: [ { collection: 'seating', q, query_by: 'code,description', per_page: 5 } ] });
            const sres = await fetch(sugUrl, { method: 'POST', headers: { 'Content-Type': 'application/json', 'X-TYPESENSE-API-KEY': apiKey }, body: sugBody });
            const sdata = await sres.json();
            const hits = ((sdata && sdata.results && sdata.results[0] && sdata.results[0].hits) || []).slice(0,5);
            if (hits.length) {
              const items = hits.map(h => (h.document && (h.document.code || h.document.description) || '')).filter(Boolean);
              outEl.innerHTML = '<div>No exact matches. Try: ' + items.map(i => '<span style="border:1px solid #ddd;border-radius:12px;padding:0.1rem 0.4rem;margin-right:0.25rem;display:inline-block">' + String(i).slice(0,40) + '</span>').join('') + '</div>';
            } else {
              outEl.innerHTML = '<div style="color:#666">No results. Try a shorter query.</div>';
            }
          } catch (_) {
            outEl.innerHTML = '<div style="color:#666">No results. Try a shorter query.</div>';
          }
        }

        const answerText = (conv && (conv.answer || conv.message)) || '';
        if (answerText && /no knowledge|don\'t have|do not have|i don\'t know|cannot answer|no information|unknown/i.test(answerText)) {
          await renderSuggestions();
          return;
        }

        const rendered = conv?.answer ? renderMarkdownLite(conv.answer)
                        : conv?.message ? renderMarkdownLite(conv.message)
                        : undefined;
        if (rendered !== undefined) {
          outEl.innerHTML = rendered;
        } else {
          outEl.textContent = JSON.stringify(data, null, 2);
        }

        // Basic deadending: if no hits, try a relaxed prefix search against baseUrl and show 5 suggestions
        const found = Number((data && data.results && data.results[0] && data.results[0].found) || 0);
        if (!found) {
          try {
            const sugUrl = `${baseUrl}/multi_search?q=${qParam}&conversation=false&conversation_stream=false&prefix=true`;
            const sugBody = JSON.stringify({ searches: [ { collection: 'seating', q, query_by: 'code,description', per_page: 5 } ] });
            const sres = await fetch(sugUrl, { method: 'POST', headers: { 'Content-Type': 'application/json', 'X-TYPESENSE-API-KEY': apiKey }, body: sugBody });
            const sdata = await sres.json();
            const hits = ((sdata && sdata.results && sdata.results[0] && sdata.results[0].hits) || []).slice(0,5);
            if (hits.length) {
              const items = hits.map(h => (h.document && (h.document.code || h.document.description) || '')).filter(Boolean);
              outEl.innerHTML += `<div style="margin-top:0.5rem">No exact matches. Try: ${items.map(i => `<span style='border:1px solid #ddd;border-radius:12px;padding:0.1rem 0.4rem;margin-right:0.25rem;display:inline-block'>${String(i).slice(0,40)}</span>`).join('')}</div>`;
            } else {
              outEl.innerHTML += `<div style="margin-top:0.5rem;color:#666">No results. Try a shorter query.</div>`;
            }
          } catch (_) {
            outEl.innerHTML += `<div style="margin-top:0.5rem;color:#666">No results. Try a shorter query.</div>`;
          }
        }
      } catch (err) {
        outEl.textContent = '[error] ' + (err?.message || String(err));
      }
    }

    goBtn.addEventListener('click', ask);
    qEl.addEventListener('keydown', (e) => { if (e.key === 'Enter') ask(); });
    resetBtn.addEventListener('click', () => { conversationId = undefined; cidEl.textContent = ''; outEl.textContent = ''; });
  </script>
</body>
</html>



